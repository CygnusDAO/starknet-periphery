// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//                                       .           .                   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡤⡀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//      █████████           ---======*.                       .         ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⢻⡀⢸⢱⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//     ███░░░░░███                                              📡  .   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⢸⡇⣿⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ███     ░░░  █████ ████  ███████ ████████   █████ ████  █████  ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⢀⢿⢁⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░███         ░░███ ░███  ███░░███░░███░░███ ░░███ ░███  ███░░   ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⡆⠸⠈⣇⣀⣇⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░███          ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███ ░░█████  ⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢀⣠⢶⣺⡇⠙⠄⠀⢘⣿⠛⠛⠓⢄⠀⠀⠀⠀⠀⠀⠀⠀
//   ░░███     ███ ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███  ░░░░██  ⠀⠀ ⠀⠀⠀⠀⠀⢀⠔⣫⣶⢟⡟⣿⣦⣤⡶⠟⠁⠀⠀⣤⣦⡑⠢⠤⠤⣀⣀⣀⠀
//    ░░█████████  ░░███████ ░░███████ ████ █████ ░░████████ ██████     ⠀⠀⠀⠀⡴⣣⣾⢟⣵⣾⢹⣿⡏⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⡻⠃
//     ░░░░░░░░░    ░░░░░███  ░░░░░███░░░░ ░░░░░   ░░░░░░░░ ░░░░░░   ⠀⠀ ⠀⠀⢀⡞⣰⡿⣡⣿⢏⣿⡿⣿⢿⡇⠀⣀⡀⠀⠀⠠⢴⣒⣒⣒⣲⠶⠋⠁⠀
//                  ███ ░███  ███ ░███ ⠀⠀⠀⠀⠀⠀⠀.⠀⠀⠀⠀ ⠀ ⠀⠀ ⠀⠀.⠀⠀⠀⠀⠀⢀⠀⠀⠀⣼⢱⣿⢡⣿⢣⣿⣟⣏⢨⢺⠁⠀⠀⢉⡽⢏⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀
//    .      *     ░░██████  ░░██████    ---===========*.               ⠀⢠⡇⣾⡇⣾⡏⣾⣏⡏⣷⣕⢸⠀⠀⠀⣸⢩⢎⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀
//                  ░░░░░░    ░░░░░░                                    ⠀⢸⣃⣿⣧⣿⣥⣿⢾⡇⣿⣿⢸⠀⠀⠀⣟⣿⣿⡼⣆⡀⠀⠀⠀⠀⠀⠀⠀
//      .                           . ⠀    .                .           ⠀⠘⣿⣇⠚⣦⠹⣷⡻⡇⣿⣿⢸⠦⠴⣚⣽⢸⣿⡇⡏⣹⠛⣲⢦⠀⠀⠀⠀
//         https://cygnusdao.finance                  .                 ⠀⠀⠘⢟⢬⢽⢷⣌⠻⣇⣿⣿⣸⣿⣯⣏⣿⣸⣿⣇⡿⠯⣡⣻⠃⠀⠀⠀⠀
//                                    ⠀⠀⠀                               ⠀⠀⠀⠈⠻⣷⣝⠽⠳⣷⣶⣶⡾⣛⣛⣋⣹⣶⡶⠶⣯⢞⠝⠁⠀⠀⠀⠀⠀
//         Cygnus-Altair: Router contract to interact with core          ⠀⠀⠀⠀⠈⠓⢽⣦⣆⣩⣙⡙⣋⢋⣙⣍⣰⣴⡯⠞⠁⠀⠀⠀⠀⠀⠀⠀          ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//                                                                       ⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠿⠿⠿⠛⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// SPDX-License-Identifier: Unlicensed
%lang starknet

// Cairo libraries
from starkware.cairo.common.pow import pow
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.cairo.common.math import assert_not_zero, assert_not_equal, assert_le
from starkware.cairo.common.uint256 import Uint256, uint256_eq, uint256_le, uint256_lt, uint256_sqrt
from starkware.cairo.common.math_cmp import is_le
from starkware.cairo.common.cairo_builtins import HashBuiltin

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//
// @title  cygnus_altair_x
// @author CygnusDAO
// @notice This contract details the functions for:
//         - Minting CygLP and CygUSD
//         - Redeeming CygLP and CygUSD
//         - Borrowing DAI
//         - Repaying DAI
//         - Liquidating user's with DAI (pay back DAI, receive CygLP + bonus liquidation reward)
//         - Liquidating user's and converting to DAI (pay back DAI, receive CygLP + bonus equivalent in DAI)
//         - Leveraging LP tokens
//         - Deleveraging LP Tokens
//
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// 2. Libraries
from src.cygnus_core.utils.context import msg_sender, address_this, block_timestamp
from src.cygnus_core.libraries.safemath import SafeUint256
from src.cygnus_core.libraries.safe_erc20 import SafeERC20
from src.cygnus_core.libraries.math_ud58x18 import MathUD58x18
from src.cygnus_core.libraries.reentrancy_guard import ReentrancyGuard
from src.cygnus_core.interfaces.interface_cygnus_altair_call import (
    BorrowCallData,
    RedeemCallData,
)

// 3. Interfaces
from src.cygnus_periphery.interfaces.interface_erc20 import IERC20
from src.cygnus_periphery.interfaces.interface_jedi_pair import IPair
from src.cygnus_periphery.interfaces.interface_cygnus_borrow import ICygnusBorrow
from src.cygnus_periphery.interfaces.interface_dex_aggregator import IHub
from src.cygnus_periphery.interfaces.interface_giza_power_plant import IGizaPowerPlant
from src.cygnus_periphery.interfaces.interface_cygnus_collateral import ICygnusCollateral

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     3. STORAGE - INTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @notice The stored address of this chain`s native token. Not sure if needed (starknet sers wen?)
@storage_var
func Native_Token() -> (native_token: felt) {
}

// @notice The stored address of the borrow token, in our case DAI. All borrowable pools get deployed with an underlying
//         lending token and all collateral pools get deployed with an underlying LP Token. We store DAI address in
//         the router to save steps.
@storage_var
func Dai() -> (dai: felt) {
    // alpha-goerli: 0x03e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9
    // mainnet: 0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3
}

// Factory
@storage_var
func Giza_Power_Plant() -> (giza_power_plant: felt) {
}

// @notice Address of the dex aggregator used to convert stablecoins to LPs and vice-versa
@storage_var
func Dex_Aggregator() -> (dex_aggregator: felt) {
    // Commercium Hub: 0x006ebfcdaa2d47342f321249a0024e1f778894a05b8bed8393ba60d6f36af7c4
}

@storage_var
func Solver() -> (solver: felt) {
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     4. CONSTRUCTOR
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @notice Constructs a router to interact with the core contracts
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    factory: felt, dex_aggregator: felt, solver: felt
) {
    // Read native token from factory (WETH)
    let (_native_token: felt) = IGizaPowerPlant.native_token(contract_address=factory);

    // Read lending token from factory (DAI)
    let (_dai: felt) = IGizaPowerPlant.dai(contract_address=factory);

    // Write to storage
    Giza_Power_Plant.write(value=factory);
    Native_Token.write(value=_native_token);
    Dai.write(value=_dai);
    Dex_Aggregator.write(value=dex_aggregator);
    Solver.write(value=solver);

    return ();
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     5. STORAGE GETTERS - EXTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

@view
func giza_power_plant{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    giza_power_plant: felt
) {
    return Giza_Power_Plant.read();
}

// @return native_token The address of Starknet's native token (if any)
@view
func native_token{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    native_token: felt
) {
    return Native_Token.read();
}

// @return dai The address of DAI on Starknet
@view
func dai{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (dai: felt) {
    return Dai.read();
}

// @return dex_aggregator The address of the Commercium Hub
@view
func dex_aggregator{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    dex_aggregator: felt
) {
    return Dex_Aggregator.read();
}

@view
func get_current_solver{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    solver: felt
) {
    return Solver.read();
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//      6. CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

// @notice Reverts the transaction if the block.timestamp is after deadline
// @param deadline A time in the future when the transaction expires
func check_deadline{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    deadline: felt
) {
    //
    // ERROR: transaction_too_old
    //
    with_attr error_message("cygnus_altair__transaction_too_old({deadline})") {
        assert_le(block_timestamp(), deadline);
    }

    return ();
}

// @notice Gets the amount of `token` we hold
func contract_balance_of{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    token: felt
) -> (amount: Uint256) {
    // Get balance of `token` of this contract
    let (amount: Uint256) = IERC20.balanceOf(contract_address=token, account=address_this());

    return (amount=amount);
}

// @dev Computes the optimal deposit of tokens to deposit into the pair contract to mint LP Tokens
// @param amount_token_a amount of token A desired to deposit
// @param reserves_token_a Reserves of token A from the DEX
// @param dex_swap_fee The fee charged by this dex for a swap (ie Uniswap = 997/1000 = 0.3%)
func optimal_deposit{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    amount_token_a: Uint256, reserves_token_a: Uint256, dex_swap_fee: Uint256
) -> (optimal_deposit: Uint256) {
    alloc_locals;
    let (with_swap_fee: Uint256) = SafeUint256.add(Uint256(low=1000, high=0), dex_swap_fee);

    // A
    let (a: Uint256) = SafeUint256.mul(with_swap_fee, reserves_token_a);

    // B
    let (b1: Uint256) = SafeUint256.mul(amount_token_a, Uint256(low=1000, high=0));
    let (b2: Uint256) = SafeUint256.mul(b1, reserves_token_a);
    let (b3: Uint256) = SafeUint256.mul(b2, Uint256(low=4, high=0));
    let (b4: Uint256) = SafeUint256.mul(b3, dex_swap_fee);

    // C
    let (c1: Uint256) = SafeUint256.mul(a, a);
    let (c2: Uint256) = SafeUint256.add(c1, b4);
    let (c3: Uint256) = uint256_sqrt(c2);

    // D
    let (d: Uint256) = SafeUint256.mul(Uint256(low=2, high=0), dex_swap_fee);

    // E
    let (e: Uint256) = SafeUint256.sub_le(c3, a);

    // Result
    let (optimal_deposit: Uint256, _) = SafeUint256.div_rem(e, d);

    return (optimal_deposit=optimal_deposit);
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//      7. NON-CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

// @notice Grants allowance to the dex' router to handle our rewards
// @param token_in The address of the token we are approving
// @param contract The contract to approve
// @param amount The amount we are approving
func approve_contract{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    token_in: felt, contract: felt, amount: Uint256
) {
    alloc_locals;

    // Get current allowance of the token from this contract to the hub
    let (current_allowance: Uint256) = IERC20.allowance(
        contract_address=token_in, owner=address_this(), spender=contract
    );

    // If allowance < swap amount, then approve max
    let (allowance_is_lt_amount) = uint256_lt(current_allowance, amount);

    if (allowance_is_lt_amount == TRUE) {
        SafeERC20.approve(
            contract_address=token_in,
            spender=contract,
            amount=Uint256(low=0, high=4722366482869645213696),
        );

        return ();
    } else {
        return ();
    }
}

// @notice Accrues interest before repaying and calculates the max amount to be repaid (never be higher than borrowed)
// @param borrowable The address of the Cygnus borrow arm where the borrowed amount was taken from
// @param amountMax The max amount that can be repaid
// @param borrower The address of the account that is repaying the borrowed amount
func repay_amount_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    borrowable: felt, amount_max: Uint256, borrower: felt
) -> (amount: Uint256) {
    alloc_locals;

    //
    // 1. Accrue to get latest owed amount in the same TX
    //
    ICygnusBorrow.accrue_interest(contract_address=borrowable);

    //
    // 2. Get borrowed DAI balance of `borrower`
    //
    let (borrowed_amount: Uint256) = ICygnusBorrow.get_borrow_balance(
        contract_address=borrowable, borrower=borrower
    );

    //
    // 3. Adjust repay amount, so pay back amount is at most the borrowed amount
    //
    let (borrowed_lt_repay_amount: felt) = uint256_lt(borrowed_amount, amount_max);

    // repay amount = amount_max > borrowed_amount ? borrowed_amount : amount_max
    if (borrowed_lt_repay_amount == TRUE) {
        return (amount=borrowed_amount);
    } else {
        return (amount=amount_max);
    }
}

// Refunds borrowable with DAI after redeeming
// @param borrowable Address of the Cygnus borrow contract
// @param token Address of the token we are repaying (USDC)
// @param borrower Address of the borrower who is repaying the loan
// @param amount_max The max available amount
func repay_and_refund_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    borrowable: felt, token: felt, borrower: felt, amount_max: Uint256
) {
    alloc_locals;

    //
    // 1. Get the correct amount of DAI to repay
    //
    let (amount: Uint256) = repay_amount_internal(
        borrowable=borrowable, amount_max=amount_max, borrower=borrower
    );

    //
    // 2. Transfer the amount to the borrowable contract
    //
    SafeERC20.transfer(contract_address=token, recipient=borrowable, amount=amount);

    //
    // 3. Empty data borrow call to borrowable
    //
    ICygnusBorrow.borrow(
        contract_address=borrowable,
        borrower=borrower,
        recipient=0,
        borrow_amount=Uint256(0, 0),
        borrow_calldata=BorrowCallData(0, 0, 0, 0, 0),
    );

    //
    // 4. Refund excess
    //
    let (amount_is_lt_max: felt) = uint256_lt(amount, amount_max);

    if (amount_is_lt_max == TRUE) {
        // Calculate refund
        let (refund_amount: Uint256) = SafeUint256.sub_le(amount_max, amount);

        // Transfer refund to borrower
        SafeERC20.transfer(contract_address=token, recipient=borrower, amount=refund_amount);
    } else {
        return ();
    }

    // Explciit return
    return ();
}

// @notice Removes liquidity from the Dex by calling the pair's `burn` function, receiving tokenA and tokenB
// @param lp_token_pair The address of the LP Token
// @param collateral The address of the Cygnus Collateral contract
// @param borrowable The address of the Cygnus Borrow contract
// @param borrower The address of the borrower
// @param redeem_tokens The amount of CygLP to redeem
// @param redeem_amount The amount of LP to redeem
func remove_liquidity_and_repay{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt,
    collateral: felt,
    borrowable: felt,
    borrower: felt,
    redeem_tokens: Uint256,
    redeem_amount: Uint256,
) {
    // Transfer LP Token back to LP Token's contract to remove liquidity
    IERC20.transfer(contract_address=lp_token_pair, recipient=lp_token_pair, amount=redeem_amount);

    let (amount_a_max: Uint256, amount_b_max: Uint256) = IPair.burn(
        contract_address=lp_token_pair, to=address_this()
    );

    //
    // ERROR: insufficient_burn_amount_a
    //
    with_attr error_message("cygnus_altair__insufficient_burn_amount_a()") {
        assert_not_zero(amount_a_max.low + amount_a_max.high);
    }

    //
    // ERROR: insufficient_burn_amount_b
    //
    with_attr error_message("cygnus_altair__insufficient_burn_amount_b()") {
        assert_not_zero(amount_b_max.low + amount_b_max.high);
    }

    let (token0: felt) = IPair.token0(contract_address=lp_token_pair);
    let (token1: felt) = IPair.token1(contract_address=lp_token_pair);

    let (amount_dai: Uint256) = convert_lp_token_to_dai(
        token0=token0, token1=token1, token0_amount=amount_a_max, token1_amount=amount_b_max
    );

    let (_dai: felt) = Dai.read();

    repay_and_refund_internal(
        borrowable=borrowable, token=_dai, borrower=borrower, amount_max=amount_dai
    );

    ICygnusCollateral.transferFrom(
        contract_address=collateral, sender=borrower, recipient=collateral, amount=redeem_tokens
    );

    return ();
}

// @notice Swaps token_in to token_out given an `amount_in` of token_in
// @notice Uses the Commercium dex aggregator to get best amount of token_out and avoids us hardcoding dex routers
// @param token_in The address of the token we are swapping
// @param token_out The address of the token we are receiving
// @param amount_in The amount of token_in we are swapping
func swap_tokens_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    token_in: felt, token_out: felt, amount_in: Uint256
) {
    alloc_locals;

    // Get the current HUB address
    let (hub: felt) = Dex_Aggregator.read();

    // Safe approve token_in internally (will return if not needed to approve token)
    approve_contract(token_in=token_in, contract=hub, amount=amount_in);

    // Swap `amount_in` to `token_in` to `token_out`
    IHub.swap_with_solver(
        contract_address=hub,
        _token_in=token_in,
        _token_out=token_out,
        _amount_in=amount_in,
        _min_amount_out=Uint256(0, 0),
        _to=address_this(),
        _solver_id=1,
    );

    return ();
}

// @notice For leverage functionality only
// @notice This function gets called after calling `borrow` on Borrow contract and having `amountUsdc` of USDC
// @param lp_token_pair The address of the LP Token
// @param token0 The address of token0 from the LP Token
// @param token1 The address of token1 from the LP Token
// @param dai_amount DAI amount to convert to token0 and token1 of the LP Token
func convert_dai_to_lp_tokens{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, token0: felt, token1: felt, dai_amount: Uint256
) -> (total_amount_token_a: Uint256, total_amount_token_b: Uint256) {
    alloc_locals;

    // Read stored variables for DAI and Native token (WETH)
    let (_dai: felt) = Dai.read();
    let (_native_token: felt) = Native_Token.read();

    //
    // 1. Check if token0 or token1 is DAI
    //
    // Placeholders to assign token0 and token1
    local token_a: felt;
    local token_b: felt;

    if ((_dai - token0) * (_dai - token1) == 0) {
        // One of them is DAI, find which one
        if (_dai == token0) {
            // Token 0 is DAI, then assign token_a = token0
            assert (token_a, token_b) = (token0, token1);

            // Avoid `if` revoke
            tempvar syscall_ptr = syscall_ptr;
            tempvar pedersen_ptr = pedersen_ptr;
            tempvar range_check_ptr = range_check_ptr;
        } else {
            // Token 1 is DAI, then assign token_a = token1
            assert (token_a, token_b) = (token1, token0);

            // Avoid `if` revoke
            tempvar syscall_ptr = syscall_ptr;
            tempvar pedersen_ptr = pedersen_ptr;
            tempvar range_check_ptr = range_check_ptr;
        }
    } else {
        //
        // 2. Neither are DAI, swap all the DAI we hold currently (after borrow) to Native token (WETH)
        //
        swap_tokens_internal(token_in=_dai, token_out=_native_token, amount_in=dai_amount);

        //
        // 3. Check if token0 or token1 from the LP is WETH, if so assign and exit loop
        //
        if ((_native_token - token0) * (_native_token - token1) == 0) {
            // One of them is WETH, find which one
            if (_native_token == token0) {
                // Token0 is WETH, then assign token_a = WETH
                assert (token_a, token_b) = (token0, token1);
            } else {
                // Token1 is WETH, assign token_b = WETH
                assert (token_a, token_b) = (token1, token0);
            }

            // Avoid `if` revoke
            tempvar syscall_ptr = syscall_ptr;
            tempvar pedersen_ptr = pedersen_ptr;
            tempvar range_check_ptr = range_check_ptr;
        } else {
            //
            // 4. Token0/Token1 are not DAI or Native, swap all native to token0
            //

            // Get our balance of Native
            let (balance_of_native: Uint256) = contract_balance_of(_native_token);

            // Neither token0/token1 are DAI or WETH. Swap all native tokens to token0
            swap_tokens_internal(
                token_in=_native_token, token_out=token0, amount_in=balance_of_native
            );

            // Assign placeholders to tokens
            assert (token_a, token_b) = (token0, token1);
        }
    }

    //
    // 5. Calculate optimal amount for an LP Deposit given tokenA reserves
    //
    let (reserves0: Uint256, reserves1: Uint256, _) = IPair.get_reserves(
        contract_address=lp_token_pair
    );

    // Get reserves of token A
    local token_a_reserves: Uint256;

    if (token_a - token0 == 0) {
        // If tokenA == token0 then reserves0 is tokenA reserves
        assert token_a_reserves = reserves0;
    } else {
        // else tokenA reserves are reserves1
        assert token_a_reserves = reserves1;
    }

    // Get our balance of Token A
    let (token_a_balance: Uint256) = contract_balance_of(token_a);

    // Calculate optimal deposit with 0.3% dex swap fee
    let (swap_amount: Uint256) = optimal_deposit(
        amount_token_a=token_a_balance,
        reserves_token_a=token_a_reserves,
        dex_swap_fee=Uint256(low=997, high=0),
    );

    //
    // 6. Perform the last swap to have 50% of token0 and 50% of token1 from the LP Token pair
    //
    swap_tokens_internal(token_in=token_a, token_out=token_b, amount_in=swap_amount);

    // Read balances of each
    let (total_amount_a: Uint256) = contract_balance_of(token0);
    let (total_amount_b: Uint256) = contract_balance_of(token1);

    return (total_amount_token_a=total_amount_a, total_amount_token_b=total_amount_b);
}

// @notice For deleverage functionality only
// @notice Converts an amount of LP Token to DAI. It is called after calling `burn` on a uniswapV2 pair, and 
//         receiving amounts of token0 and token1
// @param token0 The address of token0 from the LP Token pair
// @param token1 The address of token1 from the LP Token pair
// @param token0_amount The amount of token A to convert to DAI
// @param token1_amount The amount of token B to convert to DAI
func convert_lp_token_to_dai{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    token0: felt, token1: felt, token0_amount: Uint256, token1_amount: Uint256
) -> (dai_amount: Uint256) {
    alloc_locals;

    // Read stored variables for DAI and Native token (WETH)
    let (_dai: felt) = Dai.read();
    let (_native_token: felt) = Native_Token.read();

    //
    // 1. Check if token0 or token1 is DAI
    //
    if ((_dai - token0) * (_dai - token1) == 0) {
        // One of them is DAI, find which one
        if (_dai == token0) {
            // Token0 from the LP is DAI, swap token1 to DAI
            swap_tokens_internal(token_in=token1, token_out=_dai, amount_in=token1_amount);
        } else {
            // Else token1 from the LP is DAI, swap token0 to DAI
            swap_tokens_internal(token_in=token0, token_out=_dai, amount_in=token0_amount);
        }

        // Get the total amount we have after the swap
        let (dai_amount: Uint256) = contract_balance_of(token=_dai);

        // Explicit return
        return (dai_amount=dai_amount);
    } else {
        //
        // 2. Neither are DAI, check if any are native token (WETH)
        //
        if ((_native_token - token0) * (_native_token - token1) == 0) {
            // One of them is WETH
            if (_native_token == token0) {
                // Token0 from the LP is native token (WETH), swap token1 to WETH
                swap_tokens_internal(
                    token_in=token1, token_out=_native_token, amount_in=token1_amount
                );
            } else {
                swap_tokens_internal(
                    token_in=token0, token_out=_native_token, amount_in=token0_amount
                );
            }
        } else {
            //
            // 3. None are DAI or WETH, bridge both to WETH
            //
            swap_tokens_internal(token_in=token0, token_out=_native_token, amount_in=token0_amount);
            swap_tokens_internal(token_in=token1, token_out=_native_token, amount_in=token1_amount);
        }
    }

    //
    // 4. Swap all WETH to DAI and pay back borrowable contract
    //
    // Get WTH balance
    let (native_token_balance: Uint256) = contract_balance_of(token=_native_token);

    // swap all WETH to DAI
    swap_tokens_internal(token_in=_native_token, token_out=_dai, amount_in=native_token_balance);

    // Get DAI amount
    let (dai_amount: Uint256) = contract_balance_of(token=_dai);

    return (dai_amount=dai_amount);
}

// @notice Leverage internal function and calls borrow contract
// @param lp_token_pair The address of the LP Token
// @param collateral The address of the Cygnus collateral address for this LP Token
// @param borrowable The address of the Cygnus borrowable address for this collateral
// @param leverage_amount The amount to borrow from borrowable
// @param recipient The address of the recipient
func leverage_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt,
    collateral: felt,
    borrowable: felt,
    leverage_amount: Uint256,
    recipient: felt,
) {
    // Build calldata from the cygnus_altair_call interface to pass to borrowable
    let borrow_data = BorrowCallData(
        calldata=1,
        lp_token_pair=lp_token_pair,
        collateral=collateral,
        borrowable=borrowable,
        recipient=recipient,
    );

    // Leverage at borrowable
    ICygnusBorrow.borrow(
        contract_address=borrowable,
        borrower=recipient,
        recipient=address_this(),
        borrow_amount=leverage_amount,
        borrow_calldata=borrow_data,
    );

    return ();
}

func deleverage_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    collateral: felt, borrowable: felt, redeem_tokens: Uint256, lp_token_pair: felt
) {
    // Get the current exchange rate for CygLP <> LP
    let (current_exchange_rate: Uint256) = ICygnusCollateral.exchange_rate(
        contract_address=collateral
    );

    // Calculate the redeem LP amount
    let (redeem_amount: Uint256) = SafeUint256.mul_fixed(redeem_tokens, current_exchange_rate);

    // Cant do simple return since its a struct
    let sender: felt = msg_sender();

    // Simple redeem calldata passed
    let redeem_data = RedeemCallData(
        calldata=1,
        lp_token_pair=lp_token_pair,
        collateral=collateral,
        borrowable=borrowable,
        recipient=sender,
        redeem_tokens=redeem_tokens,
        redeem_amount=redeem_amount,
    );

    //
    // calls `flash_redeem_altair` in collateral, then collateral calls back to `altair_redeem`
    //
    ICygnusCollateral.flash_redeem_altair(
        contract_address=collateral,
        redeemer=address_this(),
        assets=redeem_amount,
        redeem_calldata=redeem_data,
    );

    return ();
}

// ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

// BORROW ─────────────────────────────────────────────

// @notice Borrow function to borrow DAI from cygnus_borrow. Before being able to borrow the `borrower` must call
//         `borrow_approve` in borrowable and set a positive allowance for this router
// @param borrowable The address of the cygnus_borrow contract which holds DAI
// @param borrow_amount The amount of DAI to borrow
// @param recipient The address of the recipient of DAI
// @param deadline The time by which the transaction must be included to effect the change
@external
func borrow{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    borrowable: felt, borrow_amount: Uint256, recipient: felt, deadline: felt
) {
    // Check transaction deadline
    check_deadline(deadline=deadline);

    // Call borrowable
    ICygnusBorrow.borrow(
        contract_address=borrowable,
        borrower=msg_sender(),
        recipient=recipient,
        borrow_amount=borrow_amount,
        borrow_calldata=BorrowCallData(0, 0, 0, 0, 0),
    );

    return ();
}

// REPAY ──────────────────────────────────────────────

// @notice Main function used in Cygnus to repay borrows
// @param borrowable The address of the cygnus_borrow contract
// @param amountMax The max amount to repay
// @param borrower Thea ddress of the borrower
// @param deadline The time by which the transaction must be included to effect the change
@external
func repay{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    borrowable: felt, amount_max: Uint256, borrower: felt, deadline: felt
) -> (amount: Uint256) {
    alloc_locals;

    // Check transaction deadline
    check_deadline(deadline=deadline);

    // Get the underlying address (DAI)
    let (underlying: felt) = ICygnusBorrow.underlying(contract_address=borrowable);

    // Calculate correct amount (max amount that can be repaid)
    let (amount: Uint256) = repay_amount_internal(
        borrowable=borrowable, amount_max=amount_max, borrower=borrower
    );

    // Transfer from sender to borrowable
    SafeERC20.transferFrom(
        contract_address=underlying, sender=msg_sender(), recipient=borrowable, amount=amount
    );

    // Borrow with recipient (0)
    ICygnusBorrow.borrow(
        contract_address=borrowable,
        borrower=borrower,
        recipient=0,
        borrow_amount=Uint256(low=0, high=0),
        borrow_calldata=BorrowCallData(0, 0, 0, 0, 0),
    );

    return (amount=amount);
}

// LIQUIDATE ──────────────────────────────────────────

// @notice Main function used in Cygnus to liquidate borrows
// @param borrowable The address of the CygnusBorrow contract
// @param amount_max The maximum amount to liquidate
// @param borrower The address of the borrower
// @param recipient The address of the recipient
// @param deadline The time by which the transaction must be included to effect the change
@external
func liquidate{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    borrowable: felt, amount_max: Uint256, borrower: felt, recipient: felt, deadline: felt
) -> (amount: Uint256, seize_tokens: Uint256) {
    // Check deadline internally
    check_deadline(deadline);

    //
    // 1. Calculate correct amount to liquidate (can never be more than `borrower`'s borrowed amount)
    //
    let (amount: Uint256) = repay_amount_internal(
        borrowable=borrowable, amount_max=amount_max, borrower=borrower
    );

    //
    // 2. Transfer the underlying asset from the liquidator back to the borrowable contract
    //

    // Get the underlying asset (DAI)
    let (underlying: felt) = ICygnusBorrow.underlying(contract_address=borrowable);

    // Safe transfer
    SafeERC20.transferFrom(
        contract_address=underlying, sender=msg_sender(), recipient=borrowable, amount=amount
    );

    //
    // 3. Liquidate position and seize CygLP from borrower and add to liquidator
    //
    let (seize_tokens: Uint256) = ICygnusBorrow.liquidate(
        contract_address=borrowable, borrower=borrower, liquidator=recipient
    );

    return (amount=amount, seize_tokens=seize_tokens);
}

// LEVERAGE ───────────────────────────────────────────

// @notice Leverage functionality of Cygnus. The borrowable contract optimistically sends DAI to this router, which
//         we then use to swap to token0 and token1 of the borrowable`s collateral underlying (an LP Token)
// @param collateral The address of the Cygnus collateral address for this LP Token
// @param borrowable The address of the Cygnus borrowable address for this collateral
// @param dai_amount_desired The amount to leverage
// @param recipient The address of the recipient
// @param deadline The time by which the transaction must be included to effect the change
@external
func leverage{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    collateral: felt, borrowable: felt, dai_amount_desired: Uint256, recipient: felt, deadline: felt
) {
    // Check deadline
    check_deadline(deadline);

    // Get LP Token pair for this collateral
    let (lp_token_pair: felt) = ICygnusCollateral.underlying(contract_address=collateral);

    // Internal
    return leverage_internal(
        lp_token_pair=lp_token_pair,
        collateral=collateral,
        borrowable=borrowable,
        leverage_amount=dai_amount_desired,
        recipient=recipient,
    );
}

// @notice Function that is called by the cygnus_borrow contract when passing `calldata` (BorrowCallData struct)
//         Will only succeed if:
//          - msg.sender is borrow contract
//          - sender is this router
//
// @param sender Address of the contract that initialized the borrow transaction (address of the router)
// @param borrower Address of the borrower that is leveraging
// @param borrow_amount The amount of DAI to leverage to buy more LP Tokens
// @param borrow_data Borrow struct simulating a simple encode/decode function of Solidity
@external
func altair_borrow{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    sender: felt, borrow_amount: Uint256, borrow_data: BorrowCallData
) {
    alloc_locals;

    //
    // ERROR: sender_not_router
    //
    with_attr error_message("cygnus_altair__sender_not_router({sender})") {
        assert sender = address_this();
    }

    //
    // ERROR: msg_sender_not_borrowable
    //
    with_attr error_message("cygnus_altair__msg_sender_not_borrowable()") {
        assert msg_sender() = borrow_data.borrowable;
    }

    // Get the tokens we need to swap into
    let (token0: felt) = IPair.token0(contract_address=borrow_data.lp_token_pair);
    let (token1: felt) = IPair.token1(contract_address=borrow_data.lp_token_pair);

    //
    // 1. Convert borrowed DAI to Token0 and Token1 from the LP Token
    //
    let (token0_amount: Uint256, token1_amount: Uint256) = convert_dai_to_lp_tokens(
        lp_token_pair=borrow_data.lp_token_pair,
        token0=token0,
        token1=token1,
        dai_amount=borrow_amount,
    );

    //
    // 2. Transfer token0 and toekn1 to the liquidity pair and call `mint` on the LP token with this router as recipient
    //
    SafeERC20.transfer(
        contract_address=token0, recipient=borrow_data.lp_token_pair, amount=token0_amount
    );
    SafeERC20.transfer(
        contract_address=token1, recipient=borrow_data.lp_token_pair, amount=token1_amount
    );
    let (liquidity: Uint256) = IPair.mint(
        contract_address=borrow_data.lp_token_pair, to=address_this()
    );

    //
    // 3. Approve collateral contract in LP Token for deposit (will return if already approved so no steps wasted)
    //
    approve_contract(
        token_in=borrow_data.lp_token_pair, contract=borrow_data.collateral, amount=liquidity
    );

    //
    // 4. Deposit the LP Token back into Cygnus and mint CygLP to `recipient`
    //
    ICygnusCollateral.deposit(
        contract_address=borrow_data.collateral, assets=liquidity, recipient=borrow_data.recipient
    );

    return ();
}

// DELEVERAGE ─────────────────────────────────────────

// @notice Main deleverage function
// @param collateral The address of the collateral of the lending pool
// @param borrowable The address of the borrowable of the lending pool
// @param redeem_tokens The amount to CygLP to deleverage
// @param deadline The time by which the transaction must be included to effect the change
@external
func deleverage{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    collateral: felt, borrowable: felt, redeem_tokens: Uint256, deadline: felt
) {
    alloc_locals;

    // Check tx deadline
    check_deadline(deadline);

    //
    // ERROR: cant_redeem_zero_tokens
    //
    with_attr error_message("cygnus_altair__cant_redeem_zero({redeem_tokens})") {
        assert_not_zero(redeem_tokens.low + redeem_tokens.high);
    }

    // Collateral`s underlying asset (LP Token)
    let (lp_token_pair: felt) = ICygnusCollateral.underlying(contract_address=collateral);

    return deleverage_internal(
        collateral=collateral,
        borrowable=borrowable,
        redeem_tokens=redeem_tokens,
        lp_token_pair=lp_token_pair,
    );
}

// @notice Function that is called by the cygnus_collateral contract when passing `calldata` (RedeemCallData struct)
//         Will only succeed if:
//          - msg.sender is borrow contract
//          - sender is this router
//
// @notice Will only succeed if: Caller is collateral contract & collateral contract was called by router
// @param sender Address of the contract that initialized the redeem transaction (address of the router)
// @param redeemAmount The amount to deleverage
// @param redeem_data The encoded byte data passed from the CygnusCollateral contract to the router
@external
func altair_redeem{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    sender: felt, redeem_amount: Uint256, redeem_data: RedeemCallData
) {
    //
    // ERROR: sender_not_router
    //
    with_attr error_message("cygnus_altair__sender_not_router({sender})") {
        assert sender = address_this();
    }

    //
    // ERROR: msg_sender_not_borrowable
    //
    with_attr error_message("cygnus_altair__msg_sender_not_borrowable()") {
        assert msg_sender() = redeem_data.collateral;
    }

    // Remove liq and repay
    return remove_liquidity_and_repay(
        lp_token_pair=redeem_data.lp_token_pair,
        collateral=redeem_data.collateral,
        borrowable=redeem_data.borrowable,
        borrower=redeem_data.recipient,
        redeem_tokens=redeem_data.redeem_tokens,
        redeem_amount=redeem_data.redeem_amount,
    );
}
